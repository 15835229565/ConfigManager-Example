2017/7/6 星期四
Config Manager 2开发计划

* 开发ConfigWindow									OK
* 将ConfigEditor 整合进 ConfigWindow				OK
* 直接删除FileUtils，不依赖，直接调用底层API		OK
* 整合ConfigEditor									OK
* 删除ConfigManagerSettings							OK
* 取消MenuItem										OK
* 设置 换行符、制表符								OK
* 支持 cvs 格式										OK
* 整合 ConfigParser 就用 Matrix out row out col		OK

* 切分Source和Config的概念							OK
* 不用在Getter里写解析方法了						OK
* 将模板放入“解析器”内部							OK

* 异步编译											OK
* 模板变量声明优化 /// <summary>					OK
* 序列化测试										OK



* 解析器
* 选择Asset输出路径

* 类型转换太乱了，要简化



* 将文件写入切割出来	ConfigParser 解析器


* 写文档
* 写宣传



编写ConfigManager 示例

1、优化运行时解析速度
	* 设计思路：在编辑器下将txt文件解析并序列化成二进制文件，运行时直接加载二进制文件即可无需解析。
	使用UnityEditor.SerializedObject 序列化文件

2、与项目加载解耦

* 配置窗口

3、将ConfigManager分离成Source 和 Example

4、支持CVS格式 

*.txt -> Serializer -> SerializableList -> Load -> Deserializer -> [Config].dict 
建立 Deserializer 反序列化器

Names Values

在每个Config里建立一个字典，用Get方法获取

Process：

从SourceFiles -> ParserInputDatas
	ConfigParser()
	SerializerParser()
	SerializableDataParser()
	DeseriazlierParser()


嵌套的层次太多，有点乱
	ParserInputData			解析器输入文件
		SourceFileData		源文件数据


SerializerParser()
	SingleSourceParser()	单个



内部定义：
Source				指原始的配置文件
Config				指输出的配置文件		
//Getter				指输出的.cs文件
Manager				指ConfigManager

SourceType			源类型
SourceBType			特指源基础类型
SourceAType			特指源数组类型

ConfigType			生成配置文件类型字符串
ConfigBType			其基础类型
ConfigAType			其数组类型

Type				System.Type
BType				基础类型
AType				数组类型


ObjectType			Type



SourceValue			配置值



BaseType			C#基础类
ArrayType			C#数组类

CSharpType(CST)		C#类型

Parser				解析器，给定输入，输出解析出来的字符串
ConfigParser		解析Config

Output				所有的Parse输出

Configs				指Config数组
Ser


Config模板定义：
ClassName					类名
PropertiesDeclaration		属性声明
ID							身份索引
IDType						索引类型
IDField						索引标识符
PropertiesParseProcess		属性的解析过程


Serializer模板定义：
ConfigName					配置类名
SourceName					原始文件名



Q&A
* 为什么需要 序列化、反序列化 这两个步骤？
* 因为[System.Serializable]不支持字典。

* 为什么要动态解析 Serializer、SerializableList、Deseriazlier？
* 因为如果不动态解析，就要使用反射去反序列化Config，那样太慢了。